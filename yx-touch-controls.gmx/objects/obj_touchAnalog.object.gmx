<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Define initial parameters for the touch analog

// Current index
_idx        = -1;

// Thumb position and max radius
thumb_x     = x;
thumb_y     = y;
thumb_r     = 16;
thumb_max   = thumb_r * 2;

// Max boundaries to check for mouse touch
bound_r     = thumb_r * 3.5;

// Deadzone
deadzone    = .25;

// Deadzone ratio multiplier
deadzone_r  = 1 - deadzone;
dead_min    = thumb_max * deadzone;

// Distance
dist        = 0;

// Touch position
touch_x     = 0;
touch_y     = 0;

// Initial down, press and "release" status
hold        = false;
press       = false;
release     = false;

// Horizontal/vertical axis' values (influenced by deadzone and radius): -1 ~ 1
h_pos       = 0;
v_pos       = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Updates the control state

// Checks if mobile or not
if ( os_type == os_android || os_type == os_ios ) {
    // Input ID and detected flag
    var dirs, 
        max_x, 
        max_y, 
        cuts;
    
    // Get direction and distance from X/Y
    var dirs    = point_direction( x, y, mouse_x, mouse_y ), 
        max_x   = lengthdir_x( thumb_r * 3, dirs ), 
        max_y   = lengthdir_y( thumb_r * 3, dirs );
        
    // First, check all the touch inputs (5 total)
    for ( var i = 0; i &lt;= 4; i++ ) {
        // Temporary position
        var temp_x  = device_mouse_x( i ), 
            temp_y  = device_mouse_y( i );
        
        // Initial break value
        cuts    = false;
        
        // Comparing ID and index
        with ( obj_touchAnalog ) {
            // If current loop is this object, continues
            if ( id == other.id ) continue;
            
            // If ID is different and index is == i
            if ( id != other.id &amp;&amp; _idx == i ) {
                // Sets to break this check and continue loop
                cuts = true;
                // Breaks this loop
                break;
            }
        }
        
        // Breaks check below and proceeds to next loop
        if ( cuts ) continue;
        
        // Check for press and hold
        if ( 
            temp_x &gt;= x - bound_r 
            &amp;&amp; temp_x &lt;= x + bound_r 
            &amp;&amp; temp_y &gt;= y - bound_r 
            &amp;&amp; temp_y &lt;= y + bound_r 
            &amp;&amp; (
                device_mouse_check_button( i, mb_left )
                || device_mouse_check_button_pressed( i, mb_left ) 
                || device_mouse_check_button_released( i, mb_left ) 
            ) 
        ) {
            // Set index
            _idx    = i;
        
            // Get direction and distance from X/Y
            dirs    = point_direction( x, y, temp_x, temp_y );
            
            // Define max X/Y threshold
            max_x   = lengthdir_x( thumb_r * 2, dirs );
            max_y   = lengthdir_y( thumb_r * 2, dirs );
            
            // Clamps thumbstick position X
            if ( max_x &lt; 0 ) {
                thumb_x = clamp( temp_x, x + max_x, x );
            } else {
                thumb_x = clamp( temp_x, x, x + max_x );
            }
            
            // Clamps thumbstick position Y
            if ( max_y &lt; 0 ) {
                thumb_y = clamp( temp_y, y + max_y, y );
            } else {
                thumb_y = clamp( temp_y, y, y + max_y );
            }
        
            // Define button states for press hold and release
            hold    = device_mouse_check_button( i, mb_left );
            press   = device_mouse_check_button_pressed( i, mb_left );
            release = device_mouse_check_button_released( i, mb_left );
            
            // Break this for loop
            break;
        } else {
            // Reset index and all states
            _idx    = -1;
            hold    = false;
            press   = false;
            release = false;
        }
    }
} else {
    // Define button states
    hold    = mouse_check_button( mb_left );
    press   = mouse_check_button_pressed( mb_left );
    release = mouse_check_button_released( mb_left );
    
    // Get direction and distance from X/Y
    var dirs    = point_direction( x, y, mouse_x, mouse_y ), 
        max_x   = lengthdir_x( thumb_r * 2, dirs ), 
        max_y   = lengthdir_y( thumb_r * 2, dirs );
    
    // Checks if mouse pointer is pressed/held inside boundaries
    if (
        mouse_x &gt;= x - bound_r 
        &amp;&amp; mouse_x &lt;= x + bound_r 
        &amp;&amp; mouse_y &gt;= y - bound_r 
        &amp;&amp; mouse_y &lt;= y + bound_r 
        &amp;&amp; ( hold || press ) 
    ) {
    // Clamps thumbstick position X
        if ( max_x &lt; 0 ) {
            thumb_x = clamp( mouse_x, x + max_x, x );
        } else {
            thumb_x = clamp( mouse_x, x, x + max_x );
        }
        
        // Clamps thumbstick position Y
        if ( max_y &lt; 0 ) {
            thumb_y = clamp( mouse_y, y + max_y, y );
        } else {
            thumb_y = clamp( mouse_y, y, y + max_y );
        }
    } else {
        // If not being held inside, set both press/hold as false
        hold    = false;
        press   = false;
    }
}
    
// Get length of distance to calculate deadzone values
dist    = point_distance( x, y, thumb_x, thumb_y ) - dead_min;
if ( dist &lt; 0 ) dist    = 0;

// If distance is above the deadzone threshold
if ( dist &gt; 0 ) {
    // Define temporary X/Y for thumbsticks
    var x_pos, y_pos;
    
    // Check thumb X
    if ( thumb_x &gt; x ) {
        x_pos   = thumb_x - x - dead_min;
    } else if ( thumb_x &lt; x ) {
        x_pos   = x - thumb_x - dead_min;
    } else {
        x_pos   = 0;
    }
    
    // Check H pos
    if ( x_pos &gt; 0 ) {
        h_pos   = x_pos / ( thumb_max * deadzone_r );
    } else {
        h_pos   = 0;
    }
    
    // Check thumb Y
    if ( thumb_y &gt; x ) {
        y_pos   = thumb_y - y - dead_min;
    } else if ( thumb_y &lt; y ) {
        y_pos   = y - thumb_y - dead_min;
    } else {
        y_pos   = 0;
    }
    
    // Check V pos
    if ( y_pos &gt; 0 ) {
        v_pos   = y_pos / ( thumb_max * deadzone_r );
    } else {
        v_pos   = 0;
    }
}

// Checks hold and press states and, if both are false, return to center
if ( thumb_x != x &amp;&amp; hold == false &amp;&amp; press == false ) {
    thumb_x = approach( thumb_x, x, thumb_r / 2 );
}

if ( thumb_y != y &amp;&amp; hold == false &amp;&amp; press == false ) {
    thumb_y = approach( thumb_y, y, thumb_r / 2 );
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="73">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draws the thumb stick on screen

// Set alpha to 0.25 to draw the outline
draw_set_alpha( .5 );

// Set outline color
draw_set_colour( c_black );

// Draw the outline circle
draw_circle( x, y, dead_min, true );

// Draw the outline circle
draw_circle( x, y, thumb_r * 3, true );

// Draw the inner circle
draw_circle( x, y, thumb_r * 2, true );

// Set alpha to 0.25 to draw the back of the stick
draw_set_alpha( .25 );

// Set color to dark gray
draw_set_colour( c_dkgray );

// Draw the limits
draw_circle( x, y, thumb_r * 3, false );

// Draw the inner limits
draw_circle( x, y, thumb_r * 2, false );

// Set alpha to 0.5 to draw the thumbstick
draw_set_alpha( .5 );

// Set outline color
draw_set_colour( c_black );

// Draw the thumb position
draw_circle( thumb_x, thumb_y, thumb_r, true );

// Set fill color
draw_set_colour( c_white );

// Draw the thumb position
draw_circle( thumb_x, thumb_y, thumb_r, false );

draw_line_width( x, y, thumb_x, thumb_y, 8 );

// Reset alpha
draw_set_alpha( 1 );
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
